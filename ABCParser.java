/* Generated By:JavaCC: Do not edit this line. ABCParser.java */
import java.io.*;

/**
 * This class is a parser for ABC format v1.6. It is generated from abc.jj.
 *
 * @author Thornton Rose
 * @version 0.1
 */
public class ABCParser implements ABCParserConstants {
   /**
    * Run parser as standalone program.
    */
   public static void main(String args[]) {
      FileInputStream in = null;
      ABCParser       parser = null;

      try {
        if (args.length < 1) {
           System.out.println("Usage: ABCParser <file>");
        } else {
           in = new FileInputStream(args[0]);

            try {
               parser = new ABCParser(in);
               parser.parse();
            } finally {
               in.close();
            }
         }
      } catch(Exception ex) {
         System.out.println(ex);
         // ex.printStackTrace(System.out);
      }
   }

   /**
    * Parse tune file.
    */
   public void parse() throws ParseException {
      tuneFile();
   }

// ----------------------------------------------------------------------------
// Grammar
// ----------------------------------------------------------------------------

// File -----------------------------------------------------------------------
  static final public void tuneFile() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case EOL:
      case WHITESPACE:
        nullLine();
        break;
      case BOOK_START:
      case FILE_NAME_START:
      case GROUP_START:
      case HISTORY_START:
      case INFO_START:
      case METER_START:
      case ORIGIN_START:
      case RHYTHM_START:
        fileField();
        break;
      case INDEX_START:
        tune();
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case EOL:
      case BOOK_START:
      case FILE_NAME_START:
      case GROUP_START:
      case HISTORY_START:
      case INFO_START:
      case INDEX_START:
      case METER_START:
      case ORIGIN_START:
      case RHYTHM_START:
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public void fileField() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOK_START:
      fieldBook();
      break;
    case FILE_NAME_START:
      fieldFileName();
      break;
    case GROUP_START:
      fieldGroup();
      break;
    case HISTORY_START:
      fieldHistory();
      break;
    case INFO_START:
      fieldInfo();
      break;
    case METER_START:
      fieldMeter();
      break;
    case ORIGIN_START:
      fieldOrigin();
      break;
    case RHYTHM_START:
      fieldRhythm();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// Tune -----------------------------------------------------------------------
  static final public void tune() throws ParseException {
   System.out.println("");
   System.out.println("(begin tune)");
    tuneHeader();
    tuneMusic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOL:
      jj_consume_token(EOL);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      System.out.println("(end tune)");
      System.out.println("");
  }

// Tune header ----------------------------------------------------------------
  static final public void tuneHeader() throws ParseException {
   Token ref = null;
    fieldIndex();
    fieldTitle();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AREA_START:
      case BOOK_START:
      case COMPOSER_START:
      case DISCOGRAPHY_START:
      case GROUP_START:
      case HISTORY_START:
      case INFO_START:
      case NOTE_LENGTH_START:
      case METER_START:
      case NOTES_START:
      case ORIGIN_START:
      case PARTS_START:
      case RHYTHM_START:
      case SOURCE_START:
      case TEMPO_START:
      case TITLE_START:
      case WORDS_START:
      case TRANS_NOTE_START:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE_START:
        fieldTitle();
        break;
      case AREA_START:
        fieldArea();
        break;
      case BOOK_START:
        fieldBook();
        break;
      case COMPOSER_START:
        fieldComposer();
        break;
      case DISCOGRAPHY_START:
        fieldDiscography();
        break;
      case GROUP_START:
        fieldGroup();
        break;
      case HISTORY_START:
        fieldHistory();
        break;
      case INFO_START:
        fieldInfo();
        break;
      case METER_START:
        fieldMeter();
        break;
      case NOTE_LENGTH_START:
        fieldNoteLength();
        break;
      case NOTES_START:
        fieldNotes();
        break;
      case ORIGIN_START:
        fieldOrigin();
        break;
      case PARTS_START:
        fieldParts();
        break;
      case RHYTHM_START:
        fieldRhythm();
        break;
      case SOURCE_START:
        fieldSource();
        break;
      case TEMPO_START:
        fieldTempo();
        break;
      case TRANS_NOTE_START:
        fieldTransNote();
        break;
      case WORDS_START:
        fieldWords();
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    fieldKey();
  }

// Tune music -----------------------------------------------------------------
  static final public void tuneMusic() throws ParseException {
   System.out.println("(music)");
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
        jj_consume_token(COMMENT);
        jj_consume_token(EOL);
        break;
      case KEY_START:
      case NOTE_LENGTH_START:
      case METER_START:
      case PARTS_START:
      case TEMPO_START:
      case TITLE_START:
      case WORDS_START:
        musicField();
        break;
      case NOTE:
      case NOTE_R:
      case REST:
      case CUSTOM_NOTATION:
      case ACCIDENTAL:
      case ACCENT_STACCATO:
      case ACCENT_ROLL:
      case ACCENT_UPBOW:
      case ACCENT_DOWNBOW:
      case GRACE_START:
      case NOTE_CHORD_START:
      case SLUR_START:
      case SLUR_END:
      case TUPLET_P:
      case BAR:
      case BAR_DOUBLE:
      case BAR_DOUBLE_START:
      case BAR_DOUBLE_END:
      case BAR_REPEAT_START:
      case BAR_REPEAT_END:
      case BAR_REPEAT_DOUBLE:
      case ACCOMP_CHORD_START:
      case REPEAT:
      case WHITESPACE:
        musicLine();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case KEY_START:
      case NOTE_LENGTH_START:
      case METER_START:
      case PARTS_START:
      case TEMPO_START:
      case TITLE_START:
      case WORDS_START:
      case NOTE:
      case NOTE_R:
      case REST:
      case CUSTOM_NOTATION:
      case ACCIDENTAL:
      case ACCENT_STACCATO:
      case ACCENT_ROLL:
      case ACCENT_UPBOW:
      case ACCENT_DOWNBOW:
      case GRACE_START:
      case NOTE_CHORD_START:
      case SLUR_START:
      case SLUR_END:
      case TUPLET_P:
      case BAR:
      case BAR_DOUBLE:
      case BAR_DOUBLE_START:
      case BAR_DOUBLE_END:
      case BAR_REPEAT_START:
      case BAR_REPEAT_END:
      case BAR_REPEAT_DOUBLE:
      case ACCOMP_CHORD_START:
      case REPEAT:
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
    }
  }

  static final public void musicField() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEY_START:
      fieldKey();
      break;
    case NOTE_LENGTH_START:
      fieldNoteLength();
      break;
    case METER_START:
      fieldMeter();
      break;
    case PARTS_START:
      fieldMusicPart();
      break;
    case TEMPO_START:
      fieldTempo();
      break;
    case TITLE_START:
      fieldTitle();
      break;
    case WORDS_START:
      fieldWords();
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void musicLine() throws ParseException {
   Token cont = null;
   Token just = null;
    label_4:
    while (true) {
      musicElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTE:
      case NOTE_R:
      case REST:
      case CUSTOM_NOTATION:
      case ACCIDENTAL:
      case ACCENT_STACCATO:
      case ACCENT_ROLL:
      case ACCENT_UPBOW:
      case ACCENT_DOWNBOW:
      case GRACE_START:
      case NOTE_CHORD_START:
      case SLUR_START:
      case SLUR_END:
      case TUPLET_P:
      case BAR:
      case BAR_DOUBLE:
      case BAR_DOUBLE_START:
      case BAR_DOUBLE_END:
      case BAR_REPEAT_START:
      case BAR_REPEAT_END:
      case BAR_REPEAT_DOUBLE:
      case ACCOMP_CHORD_START:
      case REPEAT:
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
    }
    if (jj_2_1(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JUSTIFICATION:
        just = jj_consume_token(JUSTIFICATION);
        break;
      case CONTINUATION:
        cont = jj_consume_token(CONTINUATION);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        jj_consume_token(WHITESPACE);
      }
    } else {
      ;
    }
    lineEnd();
      if (just != null) {
         System.out.println("*");
      } else if (cont != null) {
         System.out.println("\\");
      } else {
         System.out.println("");
      }
  }

  static final public void musicElement() throws ParseException {
   Token tok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTE:
    case NOTE_R:
    case REST:
    case CUSTOM_NOTATION:
    case ACCIDENTAL:
    case ACCENT_STACCATO:
    case ACCENT_ROLL:
    case ACCENT_UPBOW:
    case ACCENT_DOWNBOW:
    case GRACE_START:
    case NOTE_CHORD_START:
    case ACCOMP_CHORD_START:
      noteElement();
      break;
    case TUPLET_P:
      tupletElement();
      break;
    case BAR:
    case BAR_DOUBLE:
    case BAR_DOUBLE_START:
    case BAR_DOUBLE_END:
    case BAR_REPEAT_START:
    case BAR_REPEAT_END:
    case BAR_REPEAT_DOUBLE:
      barline();
      break;
    case REPEAT:
      tok = jj_consume_token(REPEAT);
      break;
    case SLUR_START:
      tok = jj_consume_token(SLUR_START);
      break;
    case SLUR_END:
      tok = jj_consume_token(SLUR_END);
      break;
    case WHITESPACE:
      tok = jj_consume_token(WHITESPACE);
      if (tok != null) {
         System.out.print(tok);
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void noteElement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACCOMP_CHORD_START:
      accompChord();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_6;
        }
        jj_consume_token(WHITESPACE);
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GRACE_START:
      graceNotes();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_7;
        }
        jj_consume_token(WHITESPACE);
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CUSTOM_NOTATION:
      case ACCENT_STACCATO:
      case ACCENT_ROLL:
      case ACCENT_UPBOW:
      case ACCENT_DOWNBOW:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_8;
      }
      accent();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTE:
    case NOTE_R:
    case REST:
    case ACCIDENTAL:
      noteSpec_R();
      break;
    case NOTE_CHORD_START:
      noteChord();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BROKEN_RHYTHM_LEFT:
    case BROKEN_RHYTHM_RIGHT:
      brokenRhythm();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
  }

  static final public void accompChord() throws ParseException {
   Token tok = null;
    jj_consume_token(ACCOMP_CHORD_START);
    tok = jj_consume_token(ACCOMP_CHORD_NAME);
    jj_consume_token(ACCOMP_CHORD_END);
      System.out.print("\"" + tok + "\"");
  }

  static final public void graceNotes() throws ParseException {
    jj_consume_token(GRACE_START);
      System.out.print("{");
    label_9:
    while (true) {
      notePitch();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTE:
      case ACCIDENTAL:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
    }
    jj_consume_token(GRACE_END);
      System.out.print("}");
  }

  static final public void accent() throws ParseException {
   Token tok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACCENT_STACCATO:
      tok = jj_consume_token(ACCENT_STACCATO);
      break;
    case ACCENT_ROLL:
      tok = jj_consume_token(ACCENT_ROLL);
      break;
    case ACCENT_UPBOW:
      tok = jj_consume_token(ACCENT_UPBOW);
      break;
    case ACCENT_DOWNBOW:
      tok = jj_consume_token(ACCENT_DOWNBOW);
      break;
    case CUSTOM_NOTATION:
      tok = jj_consume_token(CUSTOM_NOTATION);
      System.out.print(tok);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void noteSpec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTE:
    case ACCIDENTAL:
      notePitch();
      break;
    case REST:
      rest();
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      lengthMultiplier();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIVIDE:
      lengthDivider();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIE:
      tie();
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
  }

  static final public void noteSpec_R() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTE:
    case NOTE_R:
    case ACCIDENTAL:
      notePitch_R();
      break;
    case REST:
      rest();
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      lengthMultiplier();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIVIDE:
      lengthDivider();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIE:
      tie();
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
  }

  static final public void notePitch() throws ParseException {
   Token  accidental = null;
   Token  note = null;
   Token  octave = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACCIDENTAL:
      accidental = jj_consume_token(ACCIDENTAL);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    note = jj_consume_token(NOTE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OCTAVE_DOWN:
    case OCTAVE_UP:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OCTAVE_UP:
        octave = jj_consume_token(OCTAVE_UP);
        break;
      case OCTAVE_DOWN:
        octave = jj_consume_token(OCTAVE_DOWN);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
      System.out.print(
         (accidental == null ? "" : accidental.toString()) +
         note.toString() +
         (octave == null ? "" : octave.toString()) );
  }

  static final public void notePitch_R() throws ParseException {
   Token  accidental = null;
   Token  note = null;
   Token  octave = null;
   String noteStr = null;
   String temp = null;
   String bar = null;
   int    p = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACCIDENTAL:
      accidental = jj_consume_token(ACCIDENTAL);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOTE:
      note = jj_consume_token(NOTE);
      break;
    case NOTE_R:
      note = jj_consume_token(NOTE_R);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OCTAVE_DOWN:
    case OCTAVE_UP:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OCTAVE_UP:
        octave = jj_consume_token(OCTAVE_UP);
        break;
      case OCTAVE_DOWN:
        octave = jj_consume_token(OCTAVE_DOWN);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
      noteStr = note.toString();
      p = noteStr.indexOf(':');

      if (p >= 0) {
         /*
         if (inGrace) {
            throw new ParseException(
               "Encountered ':' before end of grace notes.");
         }
         */

         temp = noteStr.substring(0, 1);
         bar = noteStr.substring(p, p + 2);

         if ((p + 2) < noteStr.length()) {
            temp += noteStr.substring(p + 2);
         }

         noteStr = temp;
      }

      System.out.print(
         (accidental == null ? "" : accidental.toString()) +
         noteStr +
         (octave == null ? "" : octave.toString()) +
         (bar == null ? "" : " " + bar + " ") );
  }

  static final public void rest() throws ParseException {
   Token tok = null;
    tok = jj_consume_token(REST);
      System.out.print(tok);
  }

  static final public void lengthMultiplier() throws ParseException {
   Token tok = null;
    tok = jj_consume_token(NUMBER);
      System.out.print(tok);
  }

  static final public void lengthDivider() throws ParseException {
   Token div = null;
   Token len = null;
    div = jj_consume_token(DIVIDE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      len = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
      System.out.print(div);

      if (len != null) {
         System.out.print(len);
      }
  }

  static final public void tie() throws ParseException {
   Token tok = null;
    tok = jj_consume_token(TIE);
      System.out.print(tok);
  }

  static final public void noteChord() throws ParseException {
    jj_consume_token(NOTE_CHORD_START);
    label_10:
    while (true) {
      noteSpec();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTE:
      case REST:
      case ACCIDENTAL:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_10;
      }
    }
    jj_consume_token(NOTE_CHORD_END);
  }

  static final public void brokenRhythm() throws ParseException {
   Token  tok = null;
   String tokStr = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BROKEN_RHYTHM_LEFT:
      tok = jj_consume_token(BROKEN_RHYTHM_LEFT);
      break;
    case BROKEN_RHYTHM_RIGHT:
      tok = jj_consume_token(BROKEN_RHYTHM_RIGHT);
      System.out.print(tok);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void tupletElement() throws ParseException {
   Token p = null;
   Token q = null;
   Token r = null;
    p = jj_consume_token(TUPLET_P);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TUPLET_Q_OR_R:
      q = jj_consume_token(TUPLET_Q_OR_R);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TUPLET_Q_OR_R:
        r = jj_consume_token(TUPLET_Q_OR_R);
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
      System.out.print(
         p +
         (q == null ? "" : q.toString()) +
         (r == null ? "" : r.toString()) );
    label_11:
    while (true) {
      noteElement();
      if (jj_2_2(2)) {
        ;
      } else {
        break label_11;
      }
    }
  }

  static final public void barline() throws ParseException {
   Token bar = null;
   Token repeat = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BAR:
      bar = jj_consume_token(BAR);
      break;
    case BAR_DOUBLE:
      bar = jj_consume_token(BAR_DOUBLE);
      break;
    case BAR_DOUBLE_START:
      bar = jj_consume_token(BAR_DOUBLE_START);
      break;
    case BAR_DOUBLE_END:
      bar = jj_consume_token(BAR_DOUBLE_END);
      break;
    case BAR_REPEAT_START:
      bar = jj_consume_token(BAR_REPEAT_START);
      break;
    case BAR_REPEAT_END:
      bar = jj_consume_token(BAR_REPEAT_END);
      break;
    case BAR_REPEAT_DOUBLE:
      bar = jj_consume_token(BAR_REPEAT_DOUBLE);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      repeat = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
      System.out.print(
         bar +
         (repeat == null ? "" : " [" + repeat + " ") );
  }

// Fields ---------------------------------------------------------------------
  static final public void fieldArea() throws ParseException {
   String text = null;
    jj_consume_token(AREA_START);
    text = textToEOL();
      System.out.println("A:" + text);
  }

  static final public void fieldBook() throws ParseException {
   String text = null;
    jj_consume_token(BOOK_START);
    text = textToEOL();
      System.out.println("B:" + text);
  }

  static final public void fieldComposer() throws ParseException {
   String text = null;
    jj_consume_token(COMPOSER_START);
    text = textToEOL();
      System.out.println("C:" + text);
  }

  static final public void fieldDiscography() throws ParseException {
   String text = null;
    jj_consume_token(DISCOGRAPHY_START);
    text = textToEOL();
      System.out.println(text);
  }

  static final public void fieldFileName() throws ParseException {
   String text = null;
    jj_consume_token(FILE_NAME_START);
    text = textToEOL();
      System.out.println("F:" + text);
  }

  static final public void fieldGroup() throws ParseException {
   String text = null;
    jj_consume_token(GROUP_START);
    text = textToEOL();
      System.out.println("G:" + text);
  }

  static final public void fieldHistory() throws ParseException {
   String text = null;
    jj_consume_token(HISTORY_START);
    text = textToEOL();
      System.out.println("H:" + text);
  }

  static final public void fieldIndex() throws ParseException {
   Token index = null;
    jj_consume_token(INDEX_START);
    index = jj_consume_token(INDEX_NUMBER);
    lineEnd();
      System.out.println("X:" + index);
  }

  static final public void fieldInfo() throws ParseException {
   String text = null;
    jj_consume_token(INFO_START);
    text = textToEOL();
      System.out.println("I:" + text);
  }

  static final public void fieldKey() throws ParseException {
    jj_consume_token(KEY_START);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_12;
      }
      jj_consume_token(WHITESPACE);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KEY_BAGPIPE:
      keyBagpipe();
      break;
    case KEY_NOTE:
      keyGeneral();
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_13;
      }
      jj_consume_token(WHITESPACE);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    jj_consume_token(KEY_EOL);
      System.out.println("");
  }

  static final public void keyBagpipe() throws ParseException {
   Token key = null;
    // ???: Split <KEY_BAGPIPE> into two tokens?
    
       key = jj_consume_token(KEY_BAGPIPE);
      System.out.print("K:" + key);
  }

  static final public void keyGeneral() throws ParseException {
   Token        keyNote = null;
   Token        keyMode = null;
   StringBuffer globAccs = new StringBuffer();
    keyNote = jj_consume_token(KEY_NOTE);
    if (jj_2_3(2)) {
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_14;
        }
        jj_consume_token(WHITESPACE);
      }
      keyMode = jj_consume_token(KEY_MODE);
    } else {
      ;
    }
    if (jj_2_4(2)) {
      label_15:
      while (true) {
        jj_consume_token(WHITESPACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_15;
        }
      }
      globalAccidentalList(globAccs);
    } else {
      ;
    }
      System.out.print(
         "K:" + keyNote +
         (keyMode == null ? "" : " " + keyMode) +
         globAccs.toString() );
  }

  static final public void globalAccidentalList(StringBuffer sb) throws ParseException {
    globalAccidental(sb);
    label_16:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_16;
      }
      label_17:
      while (true) {
        jj_consume_token(WHITESPACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_17;
        }
      }
      globalAccidental(sb);
    }
  }

  static final public void globalAccidental(StringBuffer sb) throws ParseException {
   Token tok = null;
    tok = jj_consume_token(KEY_GLOBAL_ACCIDENTAL);
      sb.append(" " + tok.toString());
  }

  static final public void fieldMeter() throws ParseException {
   Token tok = null;
    jj_consume_token(METER_START);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case METER_COMMON:
      tok = jj_consume_token(METER_COMMON);
      break;
    case METER_CUT:
      tok = jj_consume_token(METER_CUT);
      break;
    case METER_FRACTION:
      tok = jj_consume_token(METER_FRACTION);
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    lineEnd();
      System.out.println("M:" + tok);
  }

  static final public void fieldNoteLength() throws ParseException {
   Token tok = null;
    jj_consume_token(NOTE_LENGTH_START);
    tok = jj_consume_token(NOTE_LENGTH_NOTE_UNIT);
    lineEnd();
      System.out.println("L:" + tok);
  }

  static final public void fieldNotes() throws ParseException {
   String text = null;
    jj_consume_token(NOTES_START);
    text = textToEOL();
      System.out.println("N:" + text);
  }

  static final public void fieldOrigin() throws ParseException {
   String text = null;
    jj_consume_token(ORIGIN_START);
    text = textToEOL();
      System.out.println("O:" + text);
  }

  static final public void fieldParts() throws ParseException {
   StringBuffer buf = new StringBuffer();
    jj_consume_token(PARTS_START);
    label_18:
    while (true) {
      partLabel(buf);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PART_LABEL:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_18;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(PART_EOL);
      System.out.println("P:" + buf);
  }

/*
v1.7.6 draft

void partSpec(StringBuffer sb):
{
}
{
   [partCount(sb)] 
      (partLabel(sb) | (<PART_GROUP_START> partSpec(sb) <PART_GROUP_END>))
}

void partCount(StringBuffer sb):
{
   Token count = null;
}
{
   count=<PART_COUNT>
   {
      // System.out.print(count);
      sb.append(count.toString());
   }
}
*/
  static final public void partLabel(StringBuffer sb) throws ParseException {
   Token tok = null;
    tok = jj_consume_token(PART_LABEL);
      // System.out.print(tok);
      sb.append(tok.toString());
  }

  static final public void fieldMusicPart() throws ParseException {
   StringBuffer buf = new StringBuffer();
    jj_consume_token(PARTS_START);
    partLabel(buf);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    jj_consume_token(PART_EOL);
      System.out.println("P:" + buf);
  }

  static final public void fieldRhythm() throws ParseException {
   String text = null;
    jj_consume_token(RHYTHM_START);
    text = textToEOL();
      System.out.println("R:" + text);
  }

  static final public void fieldSource() throws ParseException {
   String text = null;
    jj_consume_token(SOURCE_START);
    text = textToEOL();
      System.out.println("S:" + text);
  }

  static final public void fieldTempo() throws ParseException {
   Token count = null;
   Token unit = null;
    jj_consume_token(TEMPO_START);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEMPO_NOTE_UNIT:
      unit = jj_consume_token(TEMPO_NOTE_UNIT);
      jj_consume_token(TEMPO_ASSIGN);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    count = jj_consume_token(TEMPO_COUNT);
    lineEnd();
      System.out.println(
         "Q:" +
         (unit == null ? "" : unit + "=") +
         count.toString() );
  }

  static final public void fieldTitle() throws ParseException {
   String text = null;
    jj_consume_token(TITLE_START);
    text = textToEOL();
      System.out.println("T:" + text);
  }

  static final public void fieldTransNote() throws ParseException {
   String text = null;
    jj_consume_token(TRANS_NOTE_START);
    text = textToEOL();
      System.out.println("Z:" + text);
  }

// Words ----------------------------------------------------------------------
  static final public void fieldWords() throws ParseException {
   String text = null;
    jj_consume_token(WORDS_START);
    text = textToEOL();
      System.out.println("W:" + text);
  }

// Misc. ----------------------------------------------------------------------
  static final public void nullLine() throws ParseException {
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_19;
      }
      jj_consume_token(WHITESPACE);
    }
    lineEnd();
  }

  static final public String textToEOL() throws ParseException {
   Token text = null;
    text = jj_consume_token(TEXT_LINE);
    lineEnd();
      {if (true) return text.toString().trim();}
    throw new Error("Missing return statement in function");
  }

  static final public void lineEnd() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    jj_consume_token(EOL);
  }

  static final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  static final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  static final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  static final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  static final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  static final private boolean jj_3R_35() {
    if (jj_scan_token(ACCOMP_CHORD_START)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(ACCOMP_CHORD_NAME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_52() {
    if (jj_3R_61()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_32() {
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_69() {
    if (jj_scan_token(OCTAVE_UP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_63() {
    if (jj_scan_token(ACCIDENTAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_5() {
    Token xsp;
    if (jj_3R_27()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_27()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_21() {
    if (jj_scan_token(CONTINUATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_49() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_53() {
    if (jj_scan_token(BROKEN_RHYTHM_LEFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_31() {
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_30() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_29() {
    if (jj_3R_35()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_31()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_48() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_28() {
    if (jj_scan_token(KEY_GLOBAL_ACCIDENTAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_39() {
    if (jj_scan_token(NOTE_CHORD_START)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    if (jj_3R_52()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_52()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  static final private boolean jj_3R_62() {
    if (jj_scan_token(ACCIDENTAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_25() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NOTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_24() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_26() {
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_68() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_60() {
    if (jj_scan_token(TIE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_43() {
    if (jj_scan_token(ACCENT_ROLL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_20() {
    if (jj_scan_token(JUSTIFICATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_45() {
    if (jj_scan_token(ACCENT_DOWNBOW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_47() {
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_50()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_4() {
    Token xsp;
    if (jj_3R_25()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_25()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_3() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_24()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(KEY_MODE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_67() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_59() {
    if (jj_scan_token(DIVIDE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_22()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  static final private boolean jj_3R_46() {
    if (jj_scan_token(CUSTOM_NOTATION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_44() {
    if (jj_scan_token(ACCENT_UPBOW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_42() {
    if (jj_scan_token(ACCENT_STACCATO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_58() {
    if (jj_scan_token(NUMBER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_65() {
    if (jj_scan_token(NOTE_R)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_41() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_57() {
    if (jj_scan_token(REST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_36() {
    if (jj_scan_token(GRACE_START)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_41()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  static final private boolean jj_3R_51() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_34() {
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_64() {
    if (jj_scan_token(NOTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_70() {
    if (jj_scan_token(OCTAVE_DOWN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_54() {
    if (jj_scan_token(BROKEN_RHYTHM_RIGHT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_33() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_22() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_50() {
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_27() {
    if (jj_scan_token(WHITESPACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_2() {
    if (jj_3R_23()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static private boolean jj_initialized_once = false;
  static public ABCParserTokenManager token_source;
  static ASCII_CharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static public boolean lookingAhead = false;
  static private boolean jj_semLA;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[58];
  static final private int[] jj_la1_0 = {0x2a7c9004,0x2a7c9004,0x2a3c8000,0x1001,0xff3bc000,0xff3bc000,0x93800004,0x93800004,0x93800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x4,};
  static final private int[] jj_la1_1 = {0x0,0x0,0x0,0x0,0x7,0x7,0xf84d7cfb,0xf84d7cfb,0x3,0xf84d7cf8,0x0,0x0,0xf84d7cf8,0x0,0x0,0x0,0x4000,0x3c40,0x100b8,0x300000,0x88,0x3c40,0xa8,0x0,0x2000000,0x4000000,0xb8,0x0,0x2000000,0x4000000,0x80,0x300,0x300,0x80,0x18,0x300,0x300,0x0,0xa8,0x300000,0x800000,0x800000,0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  static final private int[] jj_la1_2 = {0x40,0x40,0x0,0x0,0x0,0x0,0x4f,0x4f,0x0,0x4f,0x30,0x40,0x4f,0x40,0x4,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x40,0x600,0x40,0x0,0x40,0x40,0x40,0xe000000,0x40000000,0x0,0x0,0x0,0x40,0x0,};
  static final private int[] jj_la1_3 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,};
  static final private JJCalls[] jj_2_rtns = new JJCalls[5];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  public ABCParser(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new ABCParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ABCParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new ABCParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ABCParser(ABCParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ABCParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 58; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  static final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[100];
    for (int i = 0; i < 100; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 58; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 100; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

  static final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  static final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
